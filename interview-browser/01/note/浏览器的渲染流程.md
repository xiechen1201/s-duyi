# 浏览器的渲染流程

输入网址，浏览器发生了什么？浏览器的背后完成了大量的工作，只是我们感知不明显而已。

本篇文章主要讲渲染的过程。

## 解析 HTML

- 二进制数据转化为 HTML 字符串

- 解析 HTML 字符串，生成 DOM 树

- 将字符串通过词法分析器转化为标记（token）

- 进行标记后，分析 Node 节点，构建出对应的 DOM 节点树

- 解析的过程可能遇到 style、link 标签，又会涉及到 CSS 的解析

- 如果遇到 script 标签，会暂停解析 HTML，下载执行 JS 代码，然后再继续解析 HTML

    - 因为 JS 代码可能存在对 DOM 的操作，所以解析 DOM 的过程必须暂停

- 最终得到 DOM 树和 CSSOM 树。

## 样式计算

主线程遍历 DOM 树，为节点计算样式，称为 computed style。

这个过程中很多预设值都会变成绝对值，例如 red ==> rgb(255, 0, 0)，相对单位转换为绝对单位 em ==> px。

这个阶段会计算出元素「所有」的样式，即使开发这没有书写的样式，则会使用默认值。 

完成这一步得到一颗具有样式的 DOM 数据，也就是 DOM + CSSOM = Render Tree。

## 布局

遍历上一步的 DOM 树，根据 DOM 节点的计算样式计算出一个布局树。

Layout Tree 和 Dom Tree 不是一一对应的，因为收到 CSS 样式的影响，例如 display: none。

布局树是直接决定显示出的页面是什么样子的。

匿名行盒（文本是不能单独存在于块盒内的）。

## 分层

分层的好处在于将来某一层改变后，仅会对该层进行后续处理，不会影响到其他的层。

主线程遍历 Layout Tree 创建一颗层次树 Layer Tree。

## 生成绘制指令

主线程根据每个层生成绘制指令，用于描述每个层如何画出来。

每一个图层对一个指令集。

指令类似 canvas 的 API。

该步骤完成后，渲染主线程的工作告一段落。

主线程将每个图层的绘制信息交给「合成线程」进行处理。

## 分块

对每个图层进行分块，划分为更多小区域。

交给更多的线程分工处理。

## 光栅化

将每一块变成位图信息。

可以理解为每一个像素点。

光栅化这个操作不是由合成线程完成的，而是由 GPU 「进程」完成的。

GUP 进程开启多个线程来完成光栅化，优先处理靠近视口的块。

## 绘制

最后才是真正的绘制。

GPU 完成最终的渲染。


## Transform 案例