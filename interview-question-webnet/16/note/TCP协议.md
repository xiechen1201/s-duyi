# TCP协议

回顾一下五层网络模型。

## TCP 收发数据流程

数据可以是任何的数据，收发数据也不像 HTTP 那样，必须是客户端到服务器。

可以是客户到服务，也可以是服务端到客户端。

传输数据的时间可以是几分钟、几小时、甚至是几天。

可以任何时间、任何方式、任何方向来发送数据和接收数据。

## 如何收发数据

对完整的数据按照字节进行编号

1byte = 8bit
1kb = 1024byte
1mb = 1024kb

发数据的时候是取出一部分数据一段一段的发。

对这部分的数据添加一个头信息，后面的部分数据也添加头信息；

### 可靠传输

数据报就是一个传输单元（部分数据+头信息）。

- C --> S 一个序列号

    - seq=x：编号为 1，2 的字节，序号就为起始字节 1

- S --> 对数据进行确认

    - ACK=1（只能取 1 和 0，0 表示本次不是一个数据确认，1 表示是一个确认数据）

    - ack=x+1：表示收到的数据，x 之前的数据我都收到了，下次我要的是 x+1 的数据

这些信息全部在头里面

## 三次握手

必须先从一方发起，客户端是发起链接者，服务器是接收者（也可以反过来）。

- 链接之前是关闭的状态

- SYN=1 seq=x

    - 头信息中，SYN 同步的，1 表示本次数据包是一个特俗的数据包，seq 表示数据序号，建立连接的时候可以发数据，也可以不发

    - 客户端进入 SYN_SEND 状态（没有收到确认的状态）

- SYN=1 seq=y ACK=1 ack=x+1

    - SYN=1 也表示同步数据，ACK=1 表示确认

    - 服务端进入 SYN_RCVD 状态

- ACK=1 ack=y+1 seq=x+1

    - 客户端收到服务端的确认，进入 ESTAB_LISHED 状态

- 服务端收到客户端的确认，进入 ESTAB_LISHED 状态

## 四次挥手

- 传输数据

- C 发送 FIN=1 seq=u 表示要断开连接，C 变成 FIN_WAIT_1 状态

    - FIN 表示要断开连接

- S 发送 ACK=1 ack=u+1 seq=v，S 变成 CLOSE_WAIT 状态

- S 发送 FIN=1 ACK=1 seq=w ack=u+1，S 变成 LAST_ACK 状态



2MSL 相当于一个数据来回的时间。

因为每一次发生都会失败，如果不等待直接就进行关闭了，万一最后一次的 C->S 过程失败了， S 就收不到确认，S 就不能关闭，S 就会重新发送信息，但是 C 以及关闭了。导致 S 不停的重发，服务的内存一致无法释放。

## HTTP 和 TCP 的关系

使用了 TCP 后就不再担心数据丢失的问题。

ajax --> HTTP 组装 --> TCP 握手 --> 服务器 --> 响应 --> 断开连接

为什么不能一直连接呢？

例如多个 Ajax、CSS、JS 使用同一个 TCP

为了节约服务器资源，每次连接都需要开辟一块内存空间。

如果不销毁，会开启非常多的内存空间。

现在 HTTP 的版本已经有一些优化了。