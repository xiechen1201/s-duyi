# 实现响应式系统 2

要实现一个响应式系统，最核心的有两个部分：

1、监听数据的读写

2、关联数据和函数

只要把这两个部分完成了，那么整个响应式系统也就基本成型了。

## 监听数据的读写

- 数据：在 JS 中能够拦截读写的方式，要么 Object.defineProperty，要么 Proxy。这两个方法针对的目标是对象，因此我们这里考虑对对象类型进行监听。

- 读写：虽然说是监听读写，但是细分下来要监听的行为如下：

  - 获取属性（读取）

  - 设置属性（写入）

  - 新增属性（写入）

  - 删除属性（写入）

  - 是否存在某个属性（读取）

  - 遍历属性（读取）

## 拦截后对应的处理

不同的行为，拦截下来后要做的事情是不一样的。整体来讲分为两大类：

- 收集器：针对读取的行为，会触发收集器去收集依赖，所谓收集依赖，其实就是建立数据和函数之间的依赖关系

- 触发器：针对写入行为，触发器会工作，触发器所做的事情就是触发数据所关联的所有函数，让这些函数重新执行

下面是不同行为对应的事情：

- 获取属性：收集器

- 设置属性：触发器

- 新增属性：触发器

- 删除属性：触发器

- 是否存在某个属性：收集器

- 遍历属性：收集器

总结起来也很简单，只要涉及到属性的访问，那就是收集器，只要涉及到属性的设置（新增、删除都算设置），那就是触发器。

## 数组中查找对象

因为在进行代理的时候，是进行了递归处理的，也就说对象里面成员包含对象的话，也会被代理，这就会导致数据中成员有对象的话，是找不到。原因很简单。比较的是原始对象和代理对象，自然找不到。

```js
console.log(arrState.includes(obj));
```

```js
const result = Reflect.get(target, key);

// 如果获取到的成员是一个对象，那么需要递归进行依赖收集
if (isObject(result)) {
  return reactive(result);
}
```

解决方案：先正常找，找不到就去原始对象中重新找一次。

## 数组改动长度

关于数组长度的改变也存在一些问题，如果是隐式的改变长度，不会触发 length 的拦截。

另外即便是显式的设置 length，这里会涉及到新增和删除，新增情况下拦截式正常的，但是在删除的情况下，不会触发 DELETE 操作，因此这里需要手动触发一下。

## 自定义是否要收集依赖

当调用 push、pop、shift、unshift、splice 这些方法的时候，因为设计到了 length 属性的变化，会触发依赖收集，这是我们不期望的。最好的方式，就是由我们来控制是否要依赖收集。