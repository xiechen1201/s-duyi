# 实现响应式系统

核心内容：

- 监听数据的读写

- 关联数据和函数

数据变化后，相应的函数全部重新执行一下。

## 监听数据的读写

- 数据

    - Object.defineProperty 和 Proxy

- 读写，细分行为

    - 获取属性（读）

    - 设置属性（写）

    - 新增属性（写）

    - 删除属性（写）

    - 是否存在某个属性（读）

    - 遍历属性（读）

## 拦截后的行为

不同的行为，拦截后的处理也不一样：

- 收集器：收集依赖，建立数据和函数的依赖关系；

- 触发器：写入行为，触发器会工作，，触发数据所关联的函数，让函数重新执行。

行为对应的触发器：

- 获取属性（读）：收集

- 设置属性（写）：触发

- 新增属性（写）：触发

- 删除属性（写）：触发

- 是否存在某个属性（读）：收集

- 遍历属性（读）：收集

总结：涉及属性的访问，那就是收集器。涉及到任何属性的设置（新增、删除都算），那就是触发器。

## 数组的操作

数组的问题：

- 代理的时候是进行了递归代理的，代理数组中的对象成员也变成了响应式对象，`arr.includes(obj)` 自然是找不到的；

    - 解决：先正常查找，找不到的话就去原始对象中重新查找；

- 如果是通过 arr[4] 的方式去新增元素，只触发了 add 的操作，没有触发 length 的拦截；

    - 解决：手动触发 length 的拦截；

- 显示设置 length，无外乎是新增和删除，新增的时候是正常的，删除的时候不会触发 delete 拦截；

## 自定义是否要进行依赖收集

当调用 push、pop、shift 的时候，因为涉及到了 length 属性的变化，会触发依赖收集，这是我们不希望的。最好的办法就是让我们来控制是否要进行依赖收集。